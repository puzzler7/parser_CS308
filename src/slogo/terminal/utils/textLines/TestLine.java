package slogo.terminal.utils.textLines;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.regex.Pattern;
import javafx.scene.Node;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.ListCell;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;

/**
 * TestLine is the cell factory that generates a TextFlow object accordingly to the type and the content of the
 * text. By considering each display entry as a listCell object in ListView, it realizes the terminal functionality as
 * an alternative to the complicated implementation of a text editor.
 * Not only the design of whole ListView, the implementation of the each TextFlow object follows the factory design pattern:
 * each Text component is generated by the factory class, ColorText.java, effectively the realization of a terminal.
 * @author Qiaoyi Fang
 */
public class TestLine extends ListCell<String> {

  private final static String OTHER_TYPE_CODE = "OTHER_TYPE";
  private final static String ERROR_MSG_CODE = "ERROR_MSG";
  private final static String USER_INPUT_CODE = "USER_INPUT";
  private final static String RESERVED_COMMAND_KEY = "RESERVED_COMMAND";
  private final static String DIGITS_KEY = "DIGITS";
  private final static String COMMENT_KEY = "COMMENT";
  private final static String OTHER_COMMAND_KEY = "OTHER_COMMAND";
  private final static String SEPARATOR_KEY = "SEPARATOR";
  private final static String SPACER_KEY = "SPACER";
  private final static String TERMINAL_INPUT_PROMPT_KEY = "TERMINAL_INPUT_PROMPT";
  private final static String NON_TERMINAL_INPUT_PROMPT_KEY = "NON_TERMINAL_INPUT_PROMPT";
  private final static String TERMINAL_USER_CODE_KEY = "TERMINAL_USER_CODE";

  private final static String LOCAL_REGEX_DICT = String
      .format("%s.regex_dict", TestLine.class.getPackageName());
  private final static String LOCAL_STRING_DICT = String
      .format("%s.string_dict", TestLine.class.getPackageName());
  private final static String LOCAL_TYPE_DICT = String
      .format("%s.type_dict", TestLine.class.getPackageName());
  private final static String RESERVE_WORD_DICT_PATH = "slogo/resources/languages/syntax/";

  private static String currentLanguage;
  private List<Map.Entry<String, Pattern>> matchDictionary;

  {
    setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
    setStyle("-fx-font-family: \"Consolas\";");
    currentLanguage = "English";
  }

  /**
   * Constructor
   * @param width the preferred width of the TextLine
   */
  public TestLine(double width) {
    super();
    setWrapText(true);
    setPrefWidth(width);
  }

  /**
   * Updates the parsing language
   *
   * @param newLanguage language string
   */
  static public void changeLanguage(String newLanguage) {
    currentLanguage = newLanguage;
  }

  @Override
  protected void updateItem(String str, boolean empty) {
    super.updateItem(str, empty);
    if (!checkEmpty(str)) {
      setGraphic(createTextFlow(str));
    } else {
      setGraphic(null);
    }
  }

  private Node createTextFlow(String str) {
    //determines the type of the text string
    matchDictionary = initializeREDictionary(LOCAL_TYPE_DICT);

    if (getType(str).equals(ERROR_MSG_CODE)) {
      return createErrorMsgFlow(str);
    } else if (getType(str).equals(USER_INPUT_CODE)) {
      return createUserInputFlow(str);
    } else {
      return createOtherFlow(str);
    }
  }

  private Node createErrorMsgFlow(String textLine) {
    String[] textsStr = textLine.split(Objects.requireNonNull(getStringFromDict(SEPARATOR_KEY)));
    TextFlow flow = new TextFlow();

    for (String textStr : textsStr) {
      ColorText text = new ColorText(textStr, ERROR_MSG_CODE);
      flow.getChildren().addAll(text, createSpacer());
    }
    return flow;
  }

  private Node createUserInputFlow(String textLine) {
    TextFlow flow = new TextFlow();
    flow.getChildren()
        .addAll(new ColorText(getPrompt(textLine), getTextStrType(getPrompt(textLine))),
            createSpacer(), createSpacer(), createSpacer());

    String[] textsStr = stripInputText(textLine).split(
        Objects.requireNonNull(getStringFromDict(SEPARATOR_KEY)));

    //adding initial prompt
    boolean commentFlag = isComment(stripInputText(textLine));

    for (String textStr : textsStr) {
      ColorText text;
      if (commentFlag) {
        text = new ColorText(textStr, COMMENT_KEY);
      } else {
        text = new ColorText(textStr, getTextStrType(textStr));
      }
      flow.getChildren().addAll(text, createSpacer());
    }
    return flow;
  }

  private Node createOtherFlow(String textLine) {

    TextFlow flow = new TextFlow();

    Text text = new Text(textLine);
    text.setFill(Color.WHITE);

    flow.getChildren().add(text);

    return flow;
  }

  private String stripInputText(String input) {
    return input.substring(Objects.requireNonNull(getStringFromDict(TERMINAL_USER_CODE_KEY)).length());
  }

  private Text createSpacer() {
    return new Text(getStringFromDict(SPACER_KEY));
  }

  private boolean checkEmpty(String str) {
    return str == null || str.equals("");
  }

  private String getTextStrType(String str) {

    if (isDigits(str)) {
      return DIGITS_KEY;
    }
    if (isReservedWord(str)) {
      return RESERVED_COMMAND_KEY;
    }
    return OTHER_COMMAND_KEY;
  }

  private boolean isDigits(String str) {
    return match(str, Objects.requireNonNull(getPatternFromDict(DIGITS_KEY)));
  }

  private boolean isComment(String str) {
    return match(str, Objects.requireNonNull(getPatternFromDict(COMMENT_KEY)));
  }

  private boolean isReservedWord(String str) {
    List<Map.Entry<String, Pattern>> reserveWordDictionary = initializeREDictionary(
        String.format("%s%s", RESERVE_WORD_DICT_PATH, currentLanguage));

    for (Map.Entry<String, Pattern> e : reserveWordDictionary) {

      if (match(str.toLowerCase(), e.getValue()) || match(str.toUpperCase(), e.getValue())) {
        return true;
      }
    }
    return false;
  }

  private String getStringFromDict(String key){
    for (Map.Entry<String, String> e : initializeStringDictionary(LOCAL_STRING_DICT)) {
      if (key.equals(e.getKey())) {
        return e.getValue();
      }
    }
    return null;
  }

  private Pattern getPatternFromDict(String key){
    for (Map.Entry<String, Pattern> e : initializeREDictionary(LOCAL_REGEX_DICT)) {
      if (key.equals(e.getKey())) {
        return e.getValue();
      }
    }
    return null;
  }

  private List<Map.Entry<String, Pattern>> initializeREDictionary(String resourcePath) {
    List<Map.Entry<String, Pattern>> RegexDict = new ArrayList<>();
    List<Map.Entry<String, String>> StringDict = initializeStringDictionary(resourcePath);

    for (Map.Entry<String, String> entry: StringDict) {
      RegexDict.add(new AbstractMap.SimpleEntry<>(entry.getKey(),
          Pattern.compile(entry.getValue(), Pattern.CASE_INSENSITIVE)));
    }

    return RegexDict;
  }

  private List<Map.Entry<String, String>> initializeStringDictionary(String resourcePath) {
    ResourceBundle resources = ResourceBundle.getBundle(resourcePath);
    List<Map.Entry<String, String>> dict = new ArrayList<>();
    for (String key : Collections.list(resources.getKeys())) {
      String value = resources.getString(key);
      dict.add(new AbstractMap.SimpleEntry<>(key, value));
    }
    return dict;
  }

  private String getType(String text) {
    for (Map.Entry<String, Pattern> e : matchDictionary) {
      if (find(text, e.getValue())) {
        return e.getKey();
      }
    }
    return OTHER_TYPE_CODE;
  }

  private String getPrompt(String textLine) {
    if (isTerminalInput(textLine)) {
      return getStringFromDict(TERMINAL_INPUT_PROMPT_KEY);
    } else {
      return getStringFromDict(NON_TERMINAL_INPUT_PROMPT_KEY);
    }
  }

  private boolean isTerminalInput(String text) {
    return find(text, Pattern.compile(
        Objects.requireNonNull(getStringFromDict(TERMINAL_USER_CODE_KEY)), Pattern.CASE_INSENSITIVE));
  }

  private boolean find(String text, Pattern regex) {
    return regex.matcher(text).find();
  }

  private boolean match(String text, Pattern regex) {
    return regex.matcher(text).matches();
  }
}
